<!DOCTYPE html>
<!-- Safari, fuck you! -->
<script async src="https://ga.jspm.io/npm:es-module-shims@1.7.0/dist/es-module-shims.js"></script>
<script type="importmap" id="iMap">
{"imports": {
	"api": "./api.js",
	"world": "./world.js",
	"definitions": "./defs.js"
}}
</script>
<style>
	@font-face {
		font-family: mc;
		src: url('../font.ttf') format('truetype');
		font-weight: normal;
		font-style: normal;
	}
</style>
<script>
	delete window.localStorage; delete window.sessionStorage
	document.fonts.forEach(font => font.load())
	onmessage = ({data}) => msgQueue.push(data)
	const postMessage = parent.postMessage.bind(parent)
	let msgQueue = []
	parent.postMessage(null, '*')
	const TEX_SIZE = 16
	;(C => {
		/**
		 * Note on performance
		 * ctx.scale(x, y) seems to be closely tied to the immediate draw action
		 * It's really hard to determine whether this has a positive or negative performance impact
		 * By all logical standards it should worsen performance, but results are really incosistent across:
		 * - Browser
		 * - Whether it's a scaled draw
		 * - CPU or GPU
		 * - current transformation matrix
		 * 
		 * Additionally, despite docs saying otherwise, specifying a negative sourceHeight in drawImage does not, in fact, flip the image
		 * which would have most likely allowed an improve in performane if it did
		 * This is actually the primary concern here (text isn't a cheap operation to begin with and it's not drawn in large quantities, but images are)
		 * 
		 * Any insight by someone who has more knowledge of the workings of Canvas API in v8, tracemonkey or applewebkit would be greatly appreciated
		 * 
		 * 
		 * An alternative solution that I may implement later is to modify the transformation matrix,
		 * and coordinates be adjusted individually for each operation (including .rect(), .circle(), ...)
		 */
		const _fillTxt = C.fillText, _strokeTxt = C.strokeText, {set: setFillStyle, get: getFillStyle} = Object.getOwnPropertyDescriptor(C, 'fillStyle'),{set: setStrokeStyle, get: getStrokeStyle} = Object.getOwnPropertyDescriptor(C, 'strokeStyle')
		C.setFillStyle = setFillStyle; C.getFillStyle = getFillStyle
		C.setStrokeStyle = setStrokeStyle; C.getStrokeStyle = getStrokeStyle
		C.fillText = function(t, x, y, s, maxW = 2147483647){
			s *= .001
			const S = 1/s
			this.scale(s, -s)
			_fillTxt.call(this, t, x*S, -y*S, maxW*S)
			this.scale(S,-S)
		}
		C.strokeText = function(t, x, y, s, maxW = 2147483647){
			s *= .001
			const S = 1/s
			this.scale(s, -s)
			_strokeTxt.call(this, t, x*S, -y*S, maxW*S)
			this.scale(S,-S)
		}
		//Canvas API sucks
		C.image = function(img, x, y, w = img.w, h = img.h, ix = 0, iy = 0, ow = img.w, oh = img.h){
			if(w > 0){
				if(h < 0){
					this.drawImage(img.canvas, img.x + ix, img.y + iy, ow, oh, x, y, w, h)
				}else{
					this.scale(1,-1)
					this.drawImage(img.canvas, img.x + ix, img.y + iy, ow, oh, x, -y, w, -h)
					this.scale(1,-1)
				}
			}else if(h < 0){
				this.scale(-1,1)
				this.drawImage(img.canvas, img.x + ix, img.y + iy, ow, oh, -x, y, -w, h)
				this.scale(-1,1)
			}else{
				this.scale(-1,-1)
				this.drawImage(img.canvas, img.x + ix, img.y + iy, ow, oh, -x, -y, -w, -h)
				this.scale(-1,-1)
			}
		}
		C.measure = function(txt){
			const {actualBoundingBoxLeft: left, actualBoundingBoxRight: right, actualBoundingBoxAscent: top, actualBoundingBoxDescent: bottom, width} = this.measureText(txt)
			return {left: left / 1000, right: right / 1000, top: top / 1000, bottom: bottom / 1000, width: width / 1000}
		}
		C.push = function(){
			//V8 says we can avoid allocation because the object does not escape. We extract props and add them directly to the array, avoiding the super expensive DOMMatrix object allocation. If you try and touch the following line, you better be sleeping with one eye open...
			const {a, b, c, d, e, f} = this.getTransform()
			this.transforms.push(f, e, d, c, b, a)
		}
		C.pop = function(){
			this.setTransform(this.transforms.pop(), this.transforms.pop(), this.transforms.pop(), this.transforms.pop(), this.transforms.pop(), this.transforms.pop())
		}
		C.peek = function(){
			const l = this.transforms.length
			this.setTransform(this.transforms[l-1], this.transforms[l-2], this.transforms[l-3], this.transforms[l-4], this.transforms[l-5], this.transforms[l-6])
		}
		C.mouse = function(){
			const {a, b, c, d, e, f} = this.getTransform()
			const det = a * d - b * c
			// x y 1
			// a c e -> x
			// b d f -> y
			return {
				x: mx * d / det - mx * c / det + (c * f - d * e) / det,
				y: my * a / det - my * b / det + (b * e - a * f) / det
			}
		}
		Object.defineProperty(C, 'fillStyle', {get: getFillStyle, set(a){this.setFillStyle(a._pattern||a)}})
		Object.defineProperty(C, 'strokeStyle', {get: getStrokeStyle, set(a){this.setStrokeStyle(a._pattern||a)}})
		C.resize = function(w, h){
			this.canvas.width = this.w = w
			this.canvas.height = this.h = h
		}
		C.crop = function(x, y, w, h){ return new _txtr(this.canvas, x, y, w, h) }
	})(CanvasRenderingContext2D.prototype)
	Math.fclamp = (a, b = 1) => a < 0 ? 0 : (a > b ? b : a)
	Math.ifloat = x => {
		let f = Math.floor(x)
		return (f >> 0) + (x - f)
	}
	for(const n of [HTMLCollection, NodeList])Object.setPrototypeOf(n.prototype, Array.prototype)
	Object.defineProperties(Array.prototype, {
		winner: {enumerable: false, value(pred){
			let best = -Infinity
			let winner = null
			const length = this.length
			for(let i = 0; i < length; i++){
				const a = this[i], score = pred(a, i, this)
				if(score > best){
					best = score
					winner = a
				}
			}
			return winner
		}},
		remove: {enumerable: false, value(a){
			let i = 0, j = 0
			for(; j < this.length; j++){
				if(j > i)this[i] = this[j]
				if(this[i] != a)i++
			}
			this.length = i
			return this
		}},
		mutmap: {enumerable: false, value(fn){
			const len = this.length
			for(let i = 0; i < len; i++)
				this[i] = fn(this[i])
			return this
		}}
	})
	const Can = (w = 100, h = 100, cpu = false) => {
		const c = document.createElement('canvas').getContext('2d', {willReadFrequently: cpu})
		c.canvas.width = c.w = w; c.canvas.height = c.h = h
		//Possible consideration: filling the array with
		c.transforms = []
		c.x = c.y = 0
		return c
	}
	const {random, abs, min, max, round, floor, ceil, ifloat, fclamp, sqrt, cbrt, atan2, sign, sin, cos, tan, PI, PI2 = PI * 2, imul } = Math

	const _mac = navigator.platform.startsWith('Mac')
const LBUTTON = 0, RBUTTON = 2, MBUTTON = 1, KEYS = {
	A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76,
	M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88,
	Y: 89, Z: 90, NUM_0: 48, NUM_1: 49, NUM_2: 50, NUM_3: 51, NUM_4: 52, NUM_5: 53, NUM_6: 54,
	NUM_7: 55, NUM_8: 56, NUM_9: 57, SPACE: 32, SYMBOL: _mac ? 192 : 223, TAB: 9, BACK: 8,
	SHIFT: 16, CTRL: 17, ALT: 18, ESC: 27, META: 91, METARIGHT: 93, CAPSLOCK: 20, UP: 38,
	RIGHT: 39, DOWN: 40, LEFT: 37, MOD: _mac ? 91 : 17, F1: 112, F2: 113, F3: 114, F4: 115,
	F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, MINUS: 189,
	PLUS: 187, OPENBR: 219, CLOSEBR: 221, SEMICOLON: 186, APOS: 222, BACKSLASH: 220, COMMA: 188,
	DOT: 190, SLASH: 191
}
Object.freeze(KEYS)

const _filecache = Object.create(null)
const _txtr = class Texture{
	constructor(img, x, y, w, h){ this.canvas = img; this.x = x; this.y = y; this.w = w; this.h = h; this._pattern = null }
	crop(x, y, w, h){ return new _txtr(this.canvas, this.x + x, this.y + y, w, h) }
	at(x, y){ return new _txtr(this.canvas, this.x + x * TEX_SIZE, this.y + y * TEX_SIZE, TEX_SIZE, TEX_SIZE) }
	pattern(rep = ''){
		if(this._pattern) return this._pattern
		const c = document.createElement('canvas')
		const ctx = c.getContext('2d')
		if(this.canvas.complete === false){
			this.canvas.addEventListener('load', () => {
				c.width = this.w; c.height = this.h
				ctx.drawImage(this.canvas, this.x, this.y, this.w, this.h, 0, 0, this.w, this.h)
				this._pattern = ctx.createPattern(c, rep)
			})
		}else{
			c.width = this.w; c.height = this.h
			ctx.drawImage(this.canvas, this.x, this.y, this.w, this.h, 0, 0, this.w, this.h)
			this._pattern = ctx.createPattern(c, rep)
		}
		return this
	}
}
const Texture = src => {
	if(_filecache[src]) return _filecache[src]
	const i = new Image()
	i.crossOrigin = 'anonymous'
	i.src = src
	loading++
	const t = new _txtr(i, 0, 0, 0, 0)
	i.onload = i.onerror = () => (i.onload=i.onerror=null,t.w=i.width,t.h=i.height,--loading||loaded())
	return t
}
const _actx = new AudioContext()
const _bgGain = _actx.createGain()
_bgGain.connect(_actx.destination)
let _volume = 0
const Audio = (src, bg = false) => {
	let buf = null
	return function play(vol = 1, pitch = 1, pan = 0, start = 0, end = NaN, ends = true){
		if(buf === null){
			buf = []
			fetch(src, {credentials: 'omit', priority: 'low'}).then(a => a.arrayBuffer()).then(a => _actx.decodeAudioData(a, b => {
				const l = buf; buf = b
				for(let i = 0; i < l.length; i++) l[i][0] = play(...l[i])
			}))
		}
		if(Array.isArray(buf)){
			const a = [vol,pitch,pan,start,end,ends]
			buf.push(a)
			return () => {
				if(Array.isArray(buf)){
					const i = buf.indexOf(a)
					if(i > -1) buf.splice(i, 1)
				}else a[0]()
			}
		}
		const source = _actx.createBufferSource()
		source.buffer = buf
		if(bg) source.connect(_bgGain)
		else{
			let dest = _actx.destination
			const volume = _volume * vol
			if(volume != 1){
				const gain = _actx.createGain()
				gain.gain.value = volume
				gain.connect(dest)
				dest = gain
			}
			if(pan != 0){
				const panner = _actx.createStereoPanner()
				panner.pan.value = min(1, max(-1, pan))
				panner.connect(dest)
				dest = panner
			}
			source.playbackRate.value = pitch
			source.connect(dest)
		}
		if(source.loop = !ends){
			source.loopStart = start
			if(end == end)source.loopEnd = end
			source.start(0, start)
		}else{
			source.start(0, start, end == end ? end - start : buf.duration)
			if(typeof ends == 'function') source.onended = ends
		}
		return () => {
			source.onended = null
			source.stop()
		}
	}
}
	let send, onpacket, download, listen
	let loading = 1, loaded = null, dt = 1 / 60, pointer
	let t = 0, TPS = 20, map = new Map(), entities = new Map()
	let meid = -1, r = 0, me = null
	let ticks = 0, world = '', gx = 0, gy = 0
	const cam = {x: 0, y: 0, z: 2}
	let mx = 0, my = 0
	let DataReader, DataWriter
	const nul = new Array(1000).fill(null)
	Array.null = len => {
		if(len <= 1000) return nul.slice(0, len)
		let a = new Array(len)
		while(len > 0) a[--len] = null
		return a
	}
	Function.returns = v => () => v
</script>
<script type="module">
	import "./bitfield.js"
	import "./chunk.js"
	import "./controls.js"
	import "./entity.js"
	import "./incomingPacket.js"
	import "./ipc.js"
	import "./pointer.js"
	import "./sounds.js"
	import "./world.js"
	import "./index.js"
	import "../data.js"

	const c = Can()
	const { requestAnimationFrame } = globalThis
	void function frame(){

		requestAnimationFrame(frame)
	}()
	
</script>